# 插入排序
### 简介
　　将无序子序列的一个或几个记录“插入”到有序子序列中。  
* 定位：在R[1……i-1]中查找R[i]的插入位置，R[1……j].key≤R[i].key<R[i].key<R[j+1……i-1].key。  
* 挤空：将R[j+1……i—1]中的所有记录位置后移一位。  
* 插入：将R[i]插入到R[j+1]的位置上。
## 直接插入排序(稳定)  
　　 整个排序过程为n-1趟插入，先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。
```cpp
void InsertSort(int r[],int n){
    int i,j;
    for(int i=1;i<n;++i){//从第二个元素开始
       if(r[i]<r[i-1]){//后者比前者大
          int temp=r[i];
          for(j=i-1;j>=0&&r[j]>temp;--j)//寻找插入位置
              r[j+1]=r[j];
          r[j+1]=temp;
       }
    }
}
//带哨兵版本
void InsertSort(int r[],int n){
    int i,j;
    for(i=2;i<=n;++i){
        r[0]=r[i];//设置哨兵
        j=i-1;
        while(r[0]<r[j]){
            r[j+1]=r[j];
            j--;
        }
        r[j+1]=r[0];
    }
}
```
　　哨兵的好处：  
　　（1）进人查找(插入位置)循环之前，它保存了r[i]的副本，使不致于因记录后移而丢失r[i]的内容；  
　　（2）在查找循环中"监视"下标变量j是否越界。一旦越界(即j=0)，因为r[0]可以和自己比较，循环判定条件不成立使得循环结束，从而避免了在该循环内的每一次均要检测j是否越界(即省略了循环判定条件"j>=1")。
### 复杂度分析
　　最好情况：O(n);最坏情况：O(n^2);平均情况：O(n^2)；空间：O(1)。
## 折半插入排序(稳定)
　由于前半部分为排好的数列，不用按顺序依次寻找插入点，采用折半查找加快插入速度。
```cpp
void BinarySort(int r[],int n){
     int i,j,low,high,mid;
     for(i=2;i<=n;++i){
        r[0]=r[i];
        low=1;
        high=i-1;
        while(low<=high){
            mid=(low+high)/2;
            if(r[0]<r[mid])
                right=mid-1;
            else
                left=mid+1;
        }
        for(j=i-1;j>high;--j){
            r[j+1]=r[j];
            r[right+1]=r[0];
        }
     }
}
```
### 复杂度分析
　　折半查找只是减少了比较次数，但是元素的移动次数不变，时间复杂度仍为O(n^2)。
## 希尔排序（不稳定）
　　分割若干个较小的子文件，将各个子文件分别进行直接插入排序，当文件达到基本有序时，在对整个文件进行直接插入排序。
### 特点
# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
