# 插入排序
## 直接插入排序(稳定)  
　　将无序子序列的一个或几个记录“插入”到有序子序列中。整个排序过程为n-1趟插入，先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序。
* 定位：在R[1……i-1]中查找R[i]的插入位置，R[1……j].key≤R[i].key<R[i].key<R[j+1……i-1].key。  
* 挤空：将R[j+1……i—1]中的所有记录位置后移一位。  
* 插入：将R[i]插入到R[j+1]的位置上。  
```cpp
void InsertSort(int r[],int n){
    int i,j;
    for(int i=1;i<n;++i){//从第二个元素开始
       if(r[i]<r[i-1]){//后者比前者大
          int temp=r[i];
          for(j=i-1;j>=0&&r[j]>temp;--j)//寻找插入位置
              r[j+1]=r[j];
          r[j+1]=temp;
       }
    }
}
//带哨兵版本
void InsertSort(int r[],int n){
    int i,j;
    for(i=2;i<=n;++i){
        r[0]=r[i];//设置哨兵
        j=i-1;
        while(r[0]<r[j]){
            r[j+1]=r[j];
            j--;
        }
        r[j+1]=r[0];
    }
}
```
　　哨兵的好处：  
　　（1）进人查找(插入位置)循环之前，它保存了r[i]的副本，使不致于因记录后移而丢失r[i]的内容；  
　　（2）在查找循环中"监视"下标变量j是否越界。一旦越界(即j=0)，因为r[0]可以和自己比较，循环判定条件不成立使得循环结束，从而避免了在该循环内的每一次均要检测j是否越界(即省略了循环判定条件"j>=1")。
### 复杂度分析
　　最好情况：O(n);最坏情况：O(n^2);平均情况：O(n^2)；空间：O(1)。
## 折半插入排序(稳定)
　由于前半部分为排好的数列，不用按顺序依次寻找插入点，采用折半查找加快插入速度。
```cpp
void BinarySort(int r[],int n){
     int i,j,low,high,mid;
     for(i=2;i<=n;++i){
        r[0]=r[i];
        low=1;
        high=i-1;
        while(low<=high){
            mid=(low+high)/2;
            if(r[0]<r[mid])
                right=mid-1;
            else
                left=mid+1;
        }
        for(j=i-1;j>high;--j){
            r[j+1]=r[j];
            r[right+1]=r[0];
        }
     }
}
```
### 复杂度分析
　　折半查找只是减少了比较次数，但是元素的移动次数不变，时间复杂度仍为O(n^2)。
## 希尔排序（不稳定）
　　分割若干个较小的子文件，将各个子文件分别进行直接插入排序，当文件达到基本有序时，在对整个文件进行直接插入排序。
```cpp
void ShellSort(int r[],int n){
    for(int d=n/2;d>0;d/=2){//设置递增序列
        for(int p=d;p<n;p++){//进行插入排序
            temp=r[p];
            for(int i=p;i>=d&&r[i-d]>temp;i-=d){//从后向前
                r[i]=r[i-d];
            r[i]=temp;
            }
        }
    }
}
void ShellSort(int r[],int n){
    int d=n/2;//递增序列元素个数
    while(d>=1){
        for(int i=d;i<n;++i)
            for(int j=i-d;j>=0;j-=d){
                if(r[j]>r[j+d]){
                    int temp=r[j];
                    r[j]=r[j+d];
                    r[j+d]=temp;
                }
            }
        d/=2;
    }
}
```
### 复杂度分析
　　最好情况：O(n^1.3);最坏情况：O(n^2);平均情况：O(nlogn)~O(n^2);空间复杂度：O(1)。
### 特点
　　增量的选取会影响希尔排序的性能。
# 选择排序
## 简单选择排序（不稳定）
　　在第i趟（共n-1趟）中,通过n-i次关键字比较,从n-i+1个记录中找出关键字最小的记录，并和第i（1≤i≤n）个记录交换。
```cpp
void SimpleSort(int r[],int n){
    int i,j,k;//k记录最小元素的位置
    int temp;//用于交换
    for(i=0;i<n-1;++i){//执行n-1趟
        k=i;
        for(j=i+1;i<n;++j){
            if(r[j]<r[k])
                k=j;
        if(i!=k){//将最小值放在i的位置
            temp=r[i];
            r[i]=r[k];
            r[k]=temp;
        }
      }
    }
}
```
### 复杂度分析
最好情况：O(n^2);最坏情况：O(n^2);平均情况：O(n^2);空间复杂度：O(1)。
## 归并排序

# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
# 插入排序
### 简介
### 算法实现
### 复杂度分析
### 特点
