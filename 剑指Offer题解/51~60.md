# 目录
* [51.数组中的逆序对](#51数组中的逆序对)  
* [52.两个链表的第一个公共节点](#52两个链表的第一个公共节点)  
* [53.1  数字在排序数组中出现的次数](#531-数字在排序数组中出现的次数)  
* [53.2  0~n-1中缺失的数字](#53.20n-1中缺失的数字)  
* [53.3  数组中数值和下标相等的元素](#533数组中数值和下标相等的元素)  
* [54.二叉搜索树的第K大节点](#54二叉搜索树的第K大节点)  
* [55.1  二叉树的深度](#551-二叉树的深度)  
* [55.2  平衡二叉树](#552-平衡二叉树)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
## 51.数组中的逆序对
[牛客链接](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
### 题目描述
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出，即输出P%1000000007，数组中没有重复数字。
### 示例
	输入：[7,5,6,4]
	输出：5        解释：(7,6)、(7,5)、(7,4)、(6,4)和(5,4)
### 思路分析

```cpp
```
[回到目录](#目录)
## 52.两个链表的第一个公共节点
[牛客链接](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
### 题目描述
输入两个链表，找出它们的第一个公共结点。
### 示例
	输入：1->2->3               返回：节点6
	             \
		      ->6->7
	             /
	        1->4
### 思路分析
* 先遍历链表得到长度，分别为m、n(m>n);
* 在较长的链表上先走(m-n)步，再同时遍历，相遇节点即为所求。
```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==nullptr||pHead2==nullptr) 
            return nullptr;
        ListNode* pNode1=pHead1;
        ListNode* pNode2=pHead2;
        int count1=1,count2=1;
        while(pNode1!=nullptr){
            pNode1=pNode1->next;
            count1++;
        }
        while(pNode2!=nullptr){
            pNode2=pNode2->next;
            count2++;
        }
        pNode1=pHead1;
        pNode2=pHead2;
        if(count1<count2){
            int n=count2-count1;
            while(n&&pNode2!=nullptr){
                pNode2=pNode2->next;
                n--;
            }
            while(pNode1!=nullptr&&pNode2!=nullptr){
                if(pNode1==pNode2){
                    return pNode1;
                    //break;
                }
                pNode1=pNode1->next;
                pNode2=pNode2->next;
            }
        }
        else {
            int n=count1-count2;
            while(n&&pNode1!=nullptr){
                pNode1=pNode1->next;
                n--;
            }
            while(pNode1!=nullptr&&pNode2!=nullptr){
                if(pNode1==pNode2){
                    return pNode1;
                    //break;
                }
                pNode1=pNode1->next;
                pNode2=pNode2->next;
            }
        }
        return nullptr;
    }
};
```
* 两个链表同时遍历，遍历到最后一个节点后，转到另一节点头部，相遇节点即为所求。
```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2){
        if(pHead1==nullptr||pHead2==nullptr) return nullptr;
        ListNode* pa=pHead1;
        ListNode* pb=pHead2;
        while(pa!=pb){
            pa=(pa==nullptr)?pHead2:pa->next;
            pb=(pb==nullptr)?pHead1:pb->next;
        }
        return pa;
    }
};
```
[回到目录](#目录)
## 53.1  数字在排序数组中出现的次数
[牛客链接](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
### 题目描述
统计一个数字在排序数组中出现的次数。
### 示例
	输入：[1,2,3,3,3,3,4,5]    k=3
	输出：4
### 思路分析
利用二分查找，分别找到第一个出现的位置和最后一个位置，相减+1即可。
```cpp
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        if(data.empty()) return 0;
        int length=data.size();
        int number=0;
        int first=GetFirstK(data,k,0,length-1);
        int last=GetLastK(data,k,0,length-1);
        if(first>-1&&last>-1)
            number=last-first+1;
        return number;
    }
	//递归写法
    int GetFirstK(vector<int>&data,int k,int start,int end){
        if(start>end) return -1;
        int mid=(start+end)/2;
        if(data[mid]==k){
            if((mid>start&&data[mid-1]!=k)||mid==start)
                return mid;
            else
                end=mid-1;
        }
        else if(data[mid]>k)
            end=mid-1;
        else 
            start=mid+1;
        return GetFirstK(data,k,start,end);
    }
	//循环写法
    int GetLastK(vector<int>&data,int k,int start,int end){
        while(start<=end){
            int mid=(start+end)>>1;
            if(data[mid]==k){
                if((mid<data.size()-1&&data[mid+1]!=k)||mid==end)
                    return mid;
                else
                    start=mid+1;
            }
            else if(data[mid]<k)
                start=mid+1;
            else
                end=mid-1;
        }
        return -1;
        }
};
```
利用数组全是整数的特性：搜索k-0.5和k+0.5应该插入的位置，然后相减即可。
```cpp
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        return biSearch(data,k+0.5)-biSearch(data,k-0.5);
    }
    int biSearch(vector<int>&data,double num){
        int start=0;
        int end=data.size()-1;
        while(start<=end){
            int mid=(end+start)/2;
            if(data[mid]<num)
                start=mid+1;
            else if(data[mid]>num)
                end=mid-1;
        }
        return start;
    }
};
```
[回到目录](#目录)
## 53.2  0~n-1中缺失的数字
### 题目描述
一个长度为n-1的递增数组中所有的数字都是唯一的，每个数字都在0~n-1内。这n个数字中有且只有一个数字不在该数组中，找出这个数字。
### 思路分析
假定m不在，则m+1在m的位置，m+2在m+1的位置，找到第一个值和下标不相等的元素的下标即可。  
利用二分查找：
* 如果中间元素的值和下标相等，则下一轮查找右边；
* 如果中间元素的值和下标不等，且前一个元素与下标相等，这个下标即为所求；
*  如果中间元素的值和下标不等，且前一个元素与下标不等，下一轮查找左边。
```cpp
int GetMissingNumber(const int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left <= right)
    {
        int middle = (right + left) >> 1;
        if(numbers[middle] != middle)
        {
            if(middle == 0 || numbers[middle - 1] == middle - 1)
                return middle;
            right = middle - 1;
        }
        else
            left = middle + 1;
    }

    if(left == length)
        return length;

    // 无效的输入，比如数组不是按要求排序的，
    // 或者有数字不在0到n-1范围之内
    return -1;
}
```
利用差值：利用公式计算0~n-1的和，记为s1，数组之和为s2，s1-s2即为所求。
[回到目录](#目录)
## 53.3  数组中数值和下标相等的元素
### 题目描述
假设一个单调递增的数组里的每个元素都是整数且唯一。编写一个函数，找出数组中任意一个数值等于其下标的元素
### 示例
	输入：[-3,-1,1,3,5]       输出：3
### 思路分析
利用二分查找：
* 如果中间元素大于下标值，右边元素一定大于其下标值，找左边；
* 如果中间元素小于下标值，左边元素一定小于其下标值，找右边；
```cpp
int GetNumberSameAsIndex(const int* numbers, int length)
{
    if(numbers == nullptr || length <= 0)
        return -1;

    int left = 0;
    int right = length - 1;
    while(left <= right)
    {
        int middle = left + ((right - left) >> 1);
        if(numbers[middle] == middle)
            return middle;

        if(numbers[middle] > middle)
            right = middle - 1;
        else
            left = middle + 1;
    }

    return -1;
}
```
[回到目录](#目录)
## 54.二叉搜索树的第K大节点
[牛客链接](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)
### 题目描述
给定一棵二叉搜索树，请找出其中的第k大的结点（第k个最小的元素）。
### 示例
	输入: root = [3,1,4,null,2], k = 2
	  3
	 / \
	1   4
	 \
	  2
	输出: 2
### 思路分析
二叉搜索树的中序遍历就是从小到大的顺序，按照中序遍历顺序找到第k个结点就是结果。
* 递归
```cpp
class Solution {
public:
    TreeNode* target=nullptr;
    int count=0;
    TreeNode* KthNode(TreeNode* pRoot, int k){
        if(pRoot==nullptr||k==0)
            return nullptr;
        helper(pRoot,k);
        return target;
    }
    void helper(TreeNode* pRoot,int k){
        if(pRoot==nullptr||count>k)
            return ;
        if(pRoot->left!=nullptr)
            helper(pRoot->left,k);
        count++;
        if(count==k)
            target= pRoot;
        if(pRoot->right!=nullptr)
            helper(pRoot->right,k);
    }
};
```
* 精简版递归
```cpp
class Solution {
    int count = 0;
public:
    TreeNode* KthNode(TreeNode* pRoot,int k)
    {
        if(pRoot){ 
                TreeNode *res = KthNode(pRoot->left, k);
                if(res!=nullptr) 
                    return res;
                count++;
                if(count == k) 
                    return pRoot;
                res = KthNode(pRoot->right,k);
                if(res!=nullptr) 
                    return res;
        }
        return nullptr;
    }
};
```
* 非递归
```cpp
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k){
        if(pRoot==nullptr||k==0)
            return nullptr;
        stack<TreeNode*>stackTree;
        TreeNode* pNode=pRoot;
        while(pNode!=nullptr||!stackTree.empty()){
            if(pNode!=nullptr){
                stackTree.push(pNode);
                pNode=pNode->left;
            }
            else{
                pNode=stackTree.top();
                stackTree.pop();
                k--;
                if(k==0){
                    return pNode;
                    
                }
                pNode=pNode->right;
            }
        }
        return nullptr;
    }
};
```
[回到目录](#目录)
## 55.1  二叉树的深度
[牛客链接](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
### 题目描述
给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
### 示例
	给定二叉树 [3,9,20,null,null,15,7]        返回最大深度3
        3
       / \
      9  20
        /  \
       15   7
### 思路分析
```cpp
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot==nullptr) return 0;
        int leftDepth=TreeDepth(pRoot->left);
        int rightDepth=TreeDepth(pRoot->right);
        return (leftDepth>rightDepth)?leftDepth+1:rightDepth+1;
    }
};
```
[回到目录](#目录)
## 55.2  平衡二叉树
[牛客链接](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/balanced-binary-tree/)
### 题目描述
输入一棵二叉树，判断该二叉树是否是平衡二叉树。一个平衡二叉树每个节点的左右两个子树的高度差的绝对值不超过1。
### 示例
	给定二叉树 [3,9,20,null,null,15,7]        返回true
        3
       / \
      9  20
        /  \
       15   7
### 思路分析
直接做法：遍历每个结点，借助上一题获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。
```cpp
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(pRoot==nullptr) return true;
        int left=TreeDepth(pRoot->left);
        int right=TreeDepth(pRoot->right);
        int diff=left-right;
        if(diff>1||diff<-1)
            return false;
        return IsBalanced_Solution(pRoot->left)&&IsBalanced_Solution(pRoot->right);
    }
    int TreeDepth(TreeNode* pRoot){
        if(pRoot==nullptr)
            return 0;
        int leftDepth=TreeDepth(pRoot->left);
        int rightDepth=TreeDepth(pRoot->right);
        return (leftDepth>rightDepth)?(leftDepth+1):(rightDepth+1);
    }
};
```
利用后序遍历进行优化：
* 直接做法存在在判断上层结点的时候，会多次重复遍历下层结点的问题。
* 后序遍历在遍历根节点之前，已经遍历了子节点，只需在遍历节点时记录深度，进行判断。
```cpp
class Solution {
public:
    bool isBalanced(TreeNode *root) {
        int depth=0;
        return helper(root,depth);
    }
    bool helper(TreeNode* root,int &depth){
        if(root==nullptr)
            return true;
        int left=0,right=0;
        if(helper(root->left,left)&&helper(root->right,right)){
            int diff=left-right;
            if(diff<=1&&diff>=-1){
                depth=1+(left>right?left:right);
                return true;
            }
        }
        return false;
    }
};
```
[回到目录](#目录)
## 56.1  数组中只出现一次的两个数字
[](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/single-number/)
### 题目描述
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
### 示例
	输入: [4,1,2,1,2]
	输出: 4
### 思路分析
数学法：2×(a+b+c)-(a+a+b+b+c)=c
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int sum=0;
        int n=nums.size();
        set<int>s;
        for(int i=0;i<n;++i){
            sum+=nums[i];
            s.insert(nums[i]);
        }
        int sumS=0;
        set<int>::iterator it;
        for(it=s.begin();it!=s.end();++it)
            sumS+=*it;
        return 2*sumS-sum;
    }
};
```
异或运算：任何一个数字异或自己都为0
[回到目录](#目录)
## 56.2  数组中唯一只出现一次的数字
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 56.2  数组中唯一只出现一次的数字
[]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 56.2  数组中唯一只出现一次的数字
[]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 56.2  数组中唯一只出现一次的数字
[]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 56.2  数组中唯一只出现一次的数字
[]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 56.2  数组中唯一只出现一次的数字
[]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
