# 目录
* [61.扑克牌中的顺子](#61扑克牌中的顺子)  
* [62.圆圈中最后剩下的数字](#62圆圈中最后剩下的数字)  
* [63.股票的最大利润](#63股票的最大利润)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
## 61.扑克牌中的顺子
[牛客链接](https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### 题目描述
从扑克牌中随机抽5张牌，判断是不是一个顺子，大小王可看成任意数字，用0表示。
### 示例
	输入:[4,2,0,5,6]
	输出:true
### 思路分析
* 将数组排序，统计数组中0的个数；
* 统计排序之后的数组中相邻数字之间的空缺总数。
* 如果空缺总数小于或者等于0的个数，则连续，反之不连续。
```cpp
class Solution {
public:
    bool IsContinuous( vector<int> numbers ) {
        if(numbers.size()<5)
            return false;
        sort(numbers.begin(),numbers.end());
        int numberOfZero=0;//记录0的个数
        int numberOfGap=0;//记录空缺数量
        for(int i=0;i<numbers.size();i++){
            if(numbers[i]==0)
                ++numberOfZero;
        }
        //统计数组中的间隔数目
        int small=numberOfZero;
        int big=small+1;
        while(big<numbers.size()){
            //两个数相等，有对子，不可能是顺子
            if(numbers[small]==numbers[big])
                return false;
            numberOfGap+=numbers[big]-numbers[small]-1;
            small=big;
            ++big;
        }
        return (numberOfGap>numberOfZero)?false:true;
    }
};
```
## 62.圆圈中最后剩下的数字
[牛客链接](https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### 题目描述
0,1,……,n-1这n个数字排成一个圆圈，从数字0开始，每次从圆圈删除第m个数字。求出圆圈里剩下的最后一个数字。
### 示例
	输入:n=5  m=3
	输出:3
### 思路分析
* 利用环形链表
```cpp

```
* 数学法
```cpp

```
## 63.股票的最大利润
[LeetCode链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
### 题目描述
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。
### 示例
	输入: [7,1,5,3,6,4]
	输出: 5
	解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
	      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
### 思路分析
动态规划：前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1天中的最小价格)。
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minProfit=INT_MAX;
        int maxProfit=0;
        for(int i=0;i<prices.size();i++){
            if(prices[i]<minProfit)
                minProfit=prices[i];
            else if(prices[i]-minProfit>maxProfit)
                maxProfit=prices[i]-minProfit;
        }
        return maxProfit;
    }
};
```
## 64.扑克牌中的顺子
[牛客链接]()
### 题目描述

### 示例

### 思路分析
## 65.扑克牌中的顺子
[牛客链接]()
### 题目描述

### 示例

### 思路分析
## 66.扑克牌中的顺子
[牛客链接]()
### 题目描述

### 示例

### 思路分析
## 67.扑克牌中的顺子
[牛客链接]()
### 题目描述

### 示例

### 思路分析
## 68.扑克牌中的顺子
[牛客链接]()
### 题目描述

### 示例

### 思路分析
