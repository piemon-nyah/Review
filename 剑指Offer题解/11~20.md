# 目录
[11.1 旋转数组的最小数字I](#111-旋转数组的最小数字i)  
[11.2 旋转数组的最小数字II](#112-旋转数组的最小数字ii)  
[12.矩阵中的路径](#12矩阵中的路径)
[13.机器人的运动范围](#13机器人的运动范围)
[14.剪绳子](#14剪绳子)
## 11.1 旋转数组的最小数字I
[牛客链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
### 题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。假设数组中不含重复元素。
### 示例
	输入: [4,5,6,7,0,1,2]
	输出: 0
### 思路分析
旋转的数组可以看成两个排序的数组，前面子数组的元素都大于或者等于后面子数组的元素，两个数组的分界线就是最小的元素。利用二分查找,找到分界线,时间复杂度为O(logN)。
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.empty()) return 0;
        int left=0;
        int right=nums.size()-1;
        int mid=left;
        while(nums[left]>nums[right]){
            if(right-left==1){
                mid=right;
                break;
            }
            mid=(left+right)/2;
            if(nums[mid]>=nums[left])
                left=mid;
            if(nums[mid]<=nums[right])
                right=mid;
        }
        return nums[mid];
    }
};
```
* 当 nums[mid] <= nums[right] 时，表示 [mid, right] 区间内的数组是非递减数组，最小元素在[left, mid] 区间内，令left = mid；
* 否则 [mid + 1, right] 区间内的数组是旋转数组，令 left = mid + 1
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int left=0,right=nums.size()-1;
        while(left<right){
            int mid=(left+right)>>1;
            if(nums[mid]<=nums[right])
                right=mid;
            else 
                left=mid+1;
                
        }
        return nums[left];
    }
};
```
[回到目录](#目录)
## 11.2 旋转数组的最小数字II
[牛客链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
### 题目描述
 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。假设数组中含有重复元素。
### 示例
	输入: [2,2,2,0,1]
	输出: 0
### 思路分析
与之前的思路一样，只不过 [1,0,1,1,1]和[1,0,1,1,1]中，在 left = 0, right = 4, mid = 2 时，无法判断最小元素在哪个区间。
* 遇到相等的情况，采用顺序查找
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.empty()) return 0;
        if(nums.size()==1) return nums[0];
        int left=0;
        int right=nums.size()-1;
        int mid=left;
         while(nums[left]>=nums[right]){
            if(right-left==1){
                mid=right;
                break;
            }
            mid=(left+right)/2;
            if(nums[mid]==nums[left]&&nums[mid]==nums[right])
                return MidInOrder(nums,left,right);
            if(nums[mid]>=nums[left])
                left=mid;
            if(nums[mid]<=nums[right])
                right=mid;
        }
        return nums[mid];
    }
    int MidInOrder(vector<int>&nums,int left,int right){
        int res=nums[left];
        for(int i=0;i<nums.size();++i){
            if(nums[i]<res)
                res=nums[i];
        }
        return res;
    }
};
```
采用right=right-1
* 若nums[right]是唯一最小值：那就不可能满足判断条件nums[mid] == nums[right]
* 若nums[right]不是唯一最小值，由于 mid < right 而 nums[mid] == nums[right]，即还有最小值存在于[left,right−1] 区间，不会丢失最小值。
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int left=0,right=nums.size()-1;
        while(left<right){
            int mid=(left+right)>>1;
            if(nums[mid]<nums[right])
                right=mid;
            else if(nums[mid]>nums[right])
                left=mid+1;
            else if(nums[mid]==nums[right])
                right--;
                
        }
        return nums[left];
    }
};
```
[回到目录](#目录)
## 12.矩阵中的路径
[牛客链接](https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### 题目描述
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。
### 示例
	 a b t g
	[c f c s] 
 	 j d e h
	路径：bfce  输出：true
	路径：abfb  输出：false
### 思路分析
* 利用回溯法，矩阵左上角的格子作为路径的起点，这个格子的字符为ch，并且ch将对应路径上的第1个字符。如果路径的第1个字符是ch，则在相邻的格子寻找第2个字符。
* 当在矩阵中定位了前n个字符的位置后，在与第n个字符对应的格子周围都没有找到第n+1个字符，回溯到第n-1个字符，重新定位第n个字符。
* 直到路径字符串的所有字符都被找到位置。
```cpp
class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str){
        if(matrix==nullptr||rows<1||cols<1||str==nullptr)
            return false;
        bool *visited=new bool[rows*cols];
        memset(visited,0,rows*cols);
        int pathLength=0;
        for(int i=0;i<rows;++i)
            for(int j=0;j<cols;++j){
                if(hasPathCore(matrix,rows,cols,str,i,j,pathLength,visited))
                    return true;
            }
        delete[] visited;
        return false;
    }
    bool hasPathCore
        (char* matrix,int rows, int cols, char* str,int row,int col,int& pathLength,bool* visited){
        if(str[pathLength]=='\0')
            return true;
        bool hasPath=false;
        if(row>=0&&col>=0&&row<rows&&col<cols
           &&matrix[row*cols+col]==str[pathLength]&&!visited[row*cols+col]){
            ++pathLength;
            visited[row*cols+col]=true;
            hasPath=hasPathCore(matrix,rows,cols,str,row,col-1,pathLength,visited)
                ||hasPathCore(matrix,rows,cols,str,row-1,col,pathLength,visited)
                ||hasPathCore(matrix,rows,cols,str,row,col+1,pathLength,visited)
                ||hasPathCore(matrix,rows,cols,str,row+1,col,pathLength,visited);
            if(!hasPath){
                --pathLength;
                visited[row*cols+col]=false;
            }
        }
        return hasPath;
    }
};
```
[回到目录](#目录)
## 13.机器人的运动范围
[牛客链接](https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### 题目描述
有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。  
例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8=19。请问该机器人能够达到多少个格子?
### 思路分析
从（0，0）开始移动，当它准备进入（i，j）时，计算能否进入，能够进入，则判断相邻的四个格子（i，j-1）、（i-1，j）、（i，j+1）和（i+1,j）。
```cpp
class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        if(threshold<0||rows<=0||cols<=0) return 0;
        bool *visited=new bool[rows*cols];
        memset(visited,0,rows*cols);
        int res=movingCountCore(threshold,rows,cols,0,0,visited);
        delete []visited;
        return res;
    }
    //统计可进入的格子数量
    int movingCountCore(int threshold,int rows,int cols,int row,int col,bool* visited){
        int count=0;
        if(check(threshold,rows,cols,row,col,visited)){
            visited[row*cols+col]=true;
            count=1+movingCountCore(threshold,rows,cols,row-1,col,visited)
                +movingCountCore(threshold,rows,cols,row,col-1,visited)
                +movingCountCore(threshold,rows,cols,row+1,col,visited)
                +movingCountCore(threshold,rows,cols,row,col+1,visited);
        }
        return count;
    }
    //判断能否进入坐标为（row，col）的格子
    bool check(int threshold,int rows,int cols,int row,int col,bool* visited){
        if(row>=0&&col>=0&&row<rows&&col<cols
           &&!visited[row*cols+col]&&getDigitSum(row)+getDigitSum(col)<=threshold)
            return true;
        return false;
    }
    //计算坐标数位之和
    int getDigitSum(int number){
        int sum=0;
        while(number>0){
            sum+=number%10;
            number/=10;
        }
        return sum;
    }              
};
```
[回到目录](#目录)
## 14.剪绳子
[LeetCode链接](https://leetcode-cn.com/problems/integer-break/)
### 题目描述
把一根绳子剪成多段，并且使得每段的长度乘积最大。
### 示例
示例1：

	输入: 2  输出: 1
	解释: 2 = 1 + 1, 1 × 1 = 1。
示例2：

	输入: 2  输出: 1
	解释: 2 = 1 + 1, 1 × 1 = 1。
### 思路分析
动态规划：
* dp[i]代表i分割之后得到的乘积最大的元素
* dp[j]不包括不分割当前元素乘积最大的情况
* 状态转移方程为dp[i]=max(dp[i],(i-j)* max(dp[j],j)),(i>j) 
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int>dp(n+1,0);
        dp[1]=1;
        for(int i=2;i<=n;++i)
            for(int j=1;j<=i;j++){
                dp[i]=max(dp[i],max(dp[j]*(i-j),(i-j)*j));//dp[i]随着j的增大不断更新变化,第一个dp[i]不能遗漏
            }
        return dp[n];
    }
};
```
贪心：
* 当n>4时,尽可能多剪出长度为3的绳子,因为3(n-3)>=2(n-2)>n。
* 当剩下的长度<=4时，则直接与之前的最大值相乘。
```cpp
class Solution {
public:
    int integerBreak(int n) {
        if(n<2)
            return 0;
        if(n==2)
            return 1;
        if(n==3)
            return 2;
        int res=1;
        while(n>4){
            res*=3;
            n-=3;
        }
        res*=n;
        return res;
    }
};
```
[回到目录](#目录)
## 15.二进制中1的个数
[牛客链接]()
### 题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
### 示例
	输入：9(1001)
	输出：2
### 思路分析
常规解法：
* 若先判断最低位是不是1，再右移，直到整个整数变为0。若输入的是负数，为保证是负数，最高位永远是1，则会陷入死循环
* 为避免死循环，不对n进行右移，而是对1进行左移。
* 先把n和1做与运算，判断n的最低位是不是1，再将1左移得到2(10)，再与n做与运算，判断次低位是不是1。
* 直到1变为0，循环次数为二进制位数，32位正数要循环32次。
```cpp
class Solution {
public:
     int  NumberOf1(int n) {
         int count=0;
         unsigned int flag=1;
         while(flag){
             if(n&flag)
                 ++count;
             flag=flag<<1;
         }
         return count;
     }
};
```
n&(n-1)：
* 把一个整数减去1，再和原整数做与运算，会把整数最右边的1变为0。
###
	n=1100,n-1=1001,n&(n-1)=1000;
	n=1101,n-1=1100,n&(n-1)=1100;
* 时间复杂度为O(m)，m为二进制中1的数目
```cpp
class Solution {
public:
     int  NumberOf1(int n) {
         int count=0;
         while(n){
             ++count;
             n=(n-1)&n;
         }
         return count;
     }
};
```
[回到目录](#目录)
## 16.数值的整数次方
[牛客链接](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
[LeetCode链接](https://leetcode-cn.com/problems/powx-n/)
### 题目描述
实现 pow(x,n),即计算x的n次幂函数
### 示例
示例1：

	输入: 2.10000, 3
	输出: 9.26100
示例2：

	输入: 2.00000, -2
	输出: 0.25000
	解释: 2-2 = 1/22 = 1/4 = 0.25
### 思路分析
需要注意指数为负数的情况：为负数则先取绝对值，再取结果的倒数。
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        if(!x&&n<0)
            return 0.0;
        unsigned int absN=(unsigned int)n;
        if(n<0)
            absN=(unsigned int)(-n);
        double res=myPowWithUnsignedN(x,absN);
        if(n<0)
            res=1.0/res;
        return res;
    }
    double myPowWithUnsignedN(double x,unsigned int n){
        double res=1.0;
        for(int i=1;i<=n;++i)
            res*=x;
        return res;
    }
};
```
快速幂：
* 使用折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘。
* 如果此时n是偶数，直接把上次递归得到的值算个平方返回即可。
* 如果是奇数，则还需要乘上个x的值。
* 如果指数小于0，则取倒数。
```cpp
class Solution {
public:
    double myPow(double x, int n){
        double res=1.0;
        for(int i=n;i!=0;i/=2){
            if(i%2!=0)
                res*=x;
            x*=x;
        }
        return n<0?1/res:res;
    }
};
```
[回到目录](#目录)
## 17.打印从1到最大的n位数
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp

```
[回到目录](#目录)
## 18.旋转数组的最小数字
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 19.旋转数组的最小数字
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 20.旋转数组的最小数字
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
