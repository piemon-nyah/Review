# 目录
* [31.栈的压入、弹出序列](#31栈的压入、弹出序列)  
* [31.1 不分行从上到下打印二叉树](#311-不分行从上到下打印二叉树)  
* [31.2 分行从上到下打印二叉树](#312-分行从上到下打印二叉树)  
* [31.3 之字形打印二叉树](#313-之字形打印二叉树)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
* [](#)  
## 31.栈的压入、弹出序列
[牛客链接](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/validate-stack-sequences/)
### 题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
### 示例
示例1：

	输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
	输出：true
	解释：我们可以按以下顺序执行：
	push(1), push(2), push(3), push(4), pop() -> 4,
	push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例2：

	输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
	输出：false
	解释：1 不能在 2 之前弹出。
### 思路分析
* 模拟堆栈操作：将原数列依次压栈，栈顶元素与所给出栈队列相比，如果相同则出栈，
* 如果不同则继续压栈，直到原数列中所有数字压栈完毕。
* 检测栈中是否为空，若空，说明出栈队列可由原数列进行栈操作得到。否则，说明出栈队列不能由原数列进行栈操作得到。
```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        if(pushed.empty()&&popped.empty()) return true;
        if(pushed.empty()||popped.empty()||pushed.size()!=popped.size())
            return false;
        stack<int>s;
        int j=0;
        for(int i=0;i<pushed.size();++i){
            s.push(pushed[i]);
            while(!s.empty()&&s.top()==popped[j]){
                s.pop();
                ++j;
            }
        }
        if(s.empty())
            return true;
        return false;
    }
};
```
[回到目录](#目录)
## 31.1 不分行从上到下打印二叉树
[牛客链接](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
### 题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
### 示例
	输入：    3                  输出：[3,9,20,null,null,15,7]
	         / \
	        9  20
	          /  \
	         15   7
### 思路分析
迭代：利用队列
```cpp
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root){
        vector<int>res;
        if(root!=nullptr){
            queue<TreeNode*>q;
            q.push(root);
            while(q.size()){
                TreeNode* pNode=q.front();
                q.pop();
                res.push_back(pNode->val);
                if(pNode->left)
                    q.push(pNode->left);
                if(pNode->right)
                    q.push(pNode->right);
            }
        }
        return res;
    }
};
```
递归：
```cpp
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int>res;
        if(root==NULL) return res;
        deque<TreeNode*>dequeTree;
        dequeTree.push_back(root);
        while(dequeTree.size()){
            TreeNode* pNode=dequeTree.front();
            dequeTree.pop_front();
            res.push_back(pNode->val);
            if(pNode->left) dequeTree.push_back(pNode->left);
            if(pNode->right) dequeTree.push_back(pNode->right);
        }
        return res;
    }
};
```
[回到目录](#目录)
## 31.2 分行从上到下打印二叉树
[牛客链接](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)
### 题目描述
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
### 示例
	输入：    3                  输出：[
	         / \                       [3],
	        9  20                      [9,20],
	          /  \                     [15,7]
	         15   7                   ]  
### 思路分析
* 迭代：在上题的基础上，增加一个变量level用来记录层数元素的个数，实现换行。
```cpp
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int>>res;
            if(!pRoot) return res;
            queue<TreeNode*>TreeQueue;
            int level;//记录层数元素个数
            TreeQueue.push(pRoot);
            while(!TreeQueue.empty()){
                vector<int>temp;//记录每层的元素
                level=TreeQueue.size();
                while(level--){
                    TreeNode* pNode=TreeQueue.front();//取出队列首元素
                    TreeQueue.pop();
                    temp.push_back(pNode->val);
                    if(pNode->left) TreeQueue.push(pNode->left);
                    if(pNode->right) TreeQueue.push(pNode->right);
                }
                res.push_back(temp);
            }
            return res;
        }
};
```
* 递归：核心就在于需要一个二维数组，和一个变量level，当level递归到上一层的个数，我们新建一个空层，继续往里面加数字。
```cpp
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int>>res;
            helper(pRoot,0,res);
            return res;
        }
        void helper(TreeNode* pRoot,int level,vector<vector<int>>&res){
            if(!pRoot) return;
            if(level==res.size()) res.push_back(vector<int>{});//res.size()记录了上一层的元素个数
            res[level].push_back(pRoot->val);
            if(pRoot->left) helper(pRoot->left,level+1,res);
            if(pRoot->right) helper(pRoot->right,level+1,res);
        }
};
```
[回到目录](#目录)
## 31.3 之字形打印二叉树
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 32.二叉搜索树的后续遍历序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
## 31.栈的压入、弹出序列
[牛客链接]()
### 题目描述
### 示例
### 思路分析
[回到目录](#目录)
