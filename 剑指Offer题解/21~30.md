# 目录
* [21.调整数组顺序使奇数位于偶数前面](#21调整数组顺序使奇数位于偶数前面)  
* [22.1 链表中倒数第K个节点](#221-链表中倒数第K个节点)  
* [22.2 删除链表的倒数第N个节点](#222-删除链表的倒数第N个节点)  
* [23.1 环形链表I](#231-环形链表i)  
* [23.1 环形链表I](#231-环形链表ii)  
* []()  
* []()  
* []()  
* []()  
* []()  
* []()  
* []()  
## 21.调整数组顺序使奇数位于偶数前面
[牛客链接](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/sort-array-by-parity/)
### 题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。
### 示例
	输入：[3,1,2,4]
	输出：[2,4,3,1]
	输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
### 思路分析
定义两个指针，从前后分别扫描数组，如果第一个指针指向一个偶数，并且第二个指针指向一个偶数，则交换，直到两个指针相遇。
```cpp
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        if(array.empty()) return;
        int p1=0;
        int p2=array.size()-1;
        while(p1<p2){
            while(p1<p2&&(array[p1]%2!=0))//向后移动p1，直到遇到偶数
                ++p1;
            while(p1<p2&&(array[p2]%2==0))//向后移动p2，直到遇到奇数
                --p2;
            if(p1<p2){
                //swap(array[p1],array[p2]);
                int temp=array[p1];
                array[p1]=array[p2];
                array[p2]=temp;
            }
        }
    }
}
```
若要求相对位置不变，可利用冒泡排序的思想，前后奇偶就交换,每次当前偶数都上浮到当前最右边
```cpp
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        if(array.empty()) return;
        for(int i=0;i<array.size();i++)
            for(int j=array.size()-1;j>i;j--){
                if(array[j]%2==1&&array[j-1]%2==0)
                    swap(array[j],array[j-1]);
            }
    }
};
```
[回到目录](#目录)
## 22.1 链表中倒数第K个节点
[牛客链接](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
### 题目描述
输入一个链表，输出该链表中倒数第k个节点。
### 示例
	输入：1->2->3->4->5, k = 2
    输出：4
### 思路分析
利用快慢指针，快指针比慢指针先走k-1步，从第k步开始，此时快指针指向第k个节点，慢指针从头部出发，当快指针指向最后一个节点时，慢指针就指向倒数第K个节点。
```cpp
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k){
        if(pListHead==nullptr||k==0)
            return nullptr;
        ListNode* pA=pListHead;
        ListNode* pB=nullptr;
        for(int i=1;i<k;++i){
            if(pA->next!=nullptr)
                pA=pA->next;
            else
                return nullptr;
        }
        pB=pListHead;
        //pA到最后一个节点停止
        while(pA->next!=nullptr){
            pA=pA->next;
            pB=pB->next;
        }
        return pB;
    }
};
```
[回到目录](#目录)
## 22.2 删除链表的倒数第N个节点
[LeetCode链接](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
### 题目描述
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头节点。
### 示例
	输入：1->2->3->4->5, n = 2
    输出：1->2->3->5
### 思路分析
同样利用快慢指针，慢指针要指向倒数第n+1个节点，快指针要先走n步。  
同时，为了避免头节点要被删除，要添加一个新的头节点，方便删除操作。
```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* fast=dummy;
        ListNode* slow=nullptr;
        for(int i=1;i<=n;++i){
            if(fast->next!=nullptr)
                fast=fast->next;
            else 
                return nullptr;
            
        }
        slow=dummy;
        while(fast->next!=nullptr){
            fast=fast->next;
            slow=slow->next;
        }
        slow->next=slow->next->next;
        return dummy->next;
    }
};  
```
[回到目录](#目录)
## 23.1 环形链表I
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle/)
### 题目描述
给定一个链表，判断链表中是否有环。  
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果pos是-1，则在该链表中没有环。
### 示例
	输入：head = [3,2,0,-4], pos = 1
	输出：true
	解释：链表中有一个环，其尾部连接到第二个节点。
### 思路分析
* 利用快慢指针，快指针移动的速度是慢指针的两倍，如果有环，则快慢指针一定会相遇。
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr&&fast->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)
                return true;
        }
        return false;
    }
};
```
* 利用哈希表
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
    set<ListNode*>myset; 
    ListNode* p=head;
    while(p!=NULL)
    {
        if(myset.count(p)==0)
            myset.insert(p);
        else return true;
        p=p->next;
    }
    return false;
    }
};
```
[回到目录](#目录)
## 23.2 环形链表II
[牛客链接](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
### 题目描述
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
### 示例
	输入：head = [3,2,0,-4], pos = 1
	输出：1
	解释：链表中有一个环，其尾部连接到第二个节点
### 思路分析
![image](https://github.com/piemon-nyah/Review/blob/master/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/%E5%9B%BE%E7%89%87/%E5%89%91%E6%8C%87offer23%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9.png)
* 慢指针移动一步，快指针移动两步；
* 2distance(慢)=diatance(快)；
* 2(F+a)=F+a+n(a+b)->F=(n-1)a+nb=(n-1)(a+b)+b；
* 第一次相遇后，慢指针从头走，快指针从相遇点继续向前走，一定在入口处相遇。
```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){//第一次相遇
                slow=head;
                while(slow!=fast){//第二次相遇
                    slow=slow->next;
                    fast=fast->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};
```
* 利用哈希表，找到第一个重复的节点
```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*>myset;
        ListNode* p=head;
        while(p){
            if(myset.count(p)==0)
                myset.insert(p);
            else return p;
            p=p->next;
        }
        return nullptr;
    }
};
```
[回到目录](#目录)
## 24.1 反转链表I
[牛客链接](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/reverse-linked-list/)
### 题目描述
输入一个链表，反转链表后，输出新链表的表头。
### 示例
	输入: 1->2->3->4->5->NULL
	输出: 5->4->3->2->1->NULL
### 思路分析
迭代：
* 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。
* pPre指向前一节点，pTemp用来存储后一节点。
* 最后返回新的头引用，即pPre。
```cpp
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead){
        if(pHead==nullptr||pHead->next==nullptr)
            return pHead;
        ListNode* pPre=nullptr;
        ListNode* pCur=pHead;
        while(pCur!=nullptr){
            ListNode* temp=pCur->next;//临时节点，暂存当前节点的下一节点，用于后移
            pCur->next=pPre;//将当前节点指向它前面的节点
            pPre=pCur;//前指针后移
            pCur=temp;//当前指针后移
        }
        return pPre;
    }
};
```
递归：
* 假设链表为：n1->n2->……->nk-1->nk->nk+1->……->nm->nullptr;
* 若从nk+1到nm已经反转：n1->n2->……->nk-1->nk->nk+1<-……<-nm;
* 希望nk+1下一个节点是nk，nk->next->next=nk;
* 要注意下一节点需要指向nullptr，否则可能会出现死循环，如只有两个节点时。
```cpp
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead){
        if(pHead==nullptr||pHead->next==nullptr)
            return pHead;
        ListNode* pNode=ReverseList(pHead->next);
        pHead->next->next=pHead;
        pHead->next=nullptr;
        return pNode;
    }
};
```
头插法：首先创建一个无意义头结点，然后把整个链表采用头插法的方式来重新插入整个链表
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* dummy = new ListNode(-1);
        ListNode* curr=head;
        while(curr!=nullptr)
        {
            ListNode* temp= curr->next;
            //头插法两步，注意顺序
            curr->next=dummy->next;//curr与dummy的next指向的同一个下一节点
            dummy->next=curr;//dummy下一节点指向curr，实现curr的插入
            curr=temp;//curr后移
        }
        return dummy->next;
    }
};
```
[回到目录](#目录)
## 24.2 反转链表II
[LeetCode链接](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
### 题目描述
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
### 示例
	输入: 1->2->3->4->5->NULL, m = 2, n = 4
	输出: 1->4->3->2->5->NULL
### 思路分析
利用双指针定位，pre定位到反转的前一个节点，然后从m到n进行翻转。
以1->2->3->4->5, m = 2, n=4 为例:
* 定位到要反转部分的头节点 2，head = 2；前驱结点 1，pre = 1；
* 当前节点的下一个节点3调整为前驱节点的下一个节点 1->3->2->4->5,
* 当前结点仍为2， 前驱结点依然是1，重复上一步操作。。。
* 1->4->3->2->5.
```cpp
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
        ListNode* dummy=new ListNode(-1);
        dummy->next=head;
        ListNode* pre=dummy;
        for(int i=1;i<m;++i){
            if(pre->next!=nullptr)
                pre=pre->next;
            else
                return nullptr;
        }
        ListNode* cur=pre->next;
        for(int i=m;i<n;++i){
            ListNode* temp=cur->next;
            //头插法思路
            cur->next=temp->next;
            temp->next=pre->next;//这里必须是pre->next,如果是cur则会丢失节点
            pre->next=temp;
        }
        return dummy->next;
    }
};
```
[回到目录](#目录)
## 25.合并两个排序的链表
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 26.树的子结构
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 27.二叉树的镜像
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 21.调整数组顺序使奇数位于偶数前面
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 21.调整数组顺序使奇数位于偶数前面
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
## 21.调整数组顺序使奇数位于偶数前面
[牛客链接]()
### 题目描述
### 示例
### 思路分析
```cpp
```
[回到目录](#目录)
