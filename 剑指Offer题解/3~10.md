# 3.数组中重复的数字
[牛客链接](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
[LeetCode链接](https://leetcode-cn.com/problems/contains-duplicate/)
### 题目描述
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 
### 示例
    输入：{2,3,1,0,2,5,3}
    输出：2或者3
### 思路分析
* 先排序，在遍历扫描，找到第一个a[i]!=[i]的元素输出，排序所需时间复杂度为O(nlogn)。  
* 利用哈希表，从头到尾扫描，如果哈希表中没有这个元素，则加入，有则输出。利用哈希表可以实现O(1)时间的判断，但需要额外的O(n)空间建立哈希表。  
* 利用数组特性，重排数组。数组中的数字都在0~n-1的范围内，若没有重复元素，则数字与下标应该相等，有重复则存在冲突位置，即某一位置需要放多个相等的数字。
当扫描到i位置时，若 a[i]==i，则继续,若 a[i]!=i,则与 a[a[i]] 进行交换，将 a[i] 放到属于它的位置，如果 a[i]==a[a[i]] 则找到重复数字，位置冲突。
```cpp
class Solution {
public:
        bool duplicate(int numbers[], int length, int* duplication) {
            if(numbers==nullptr||length<=0)//传参错误
                return false;
            for(int i=0;i<length;++i){
                if(numbers[i]<0||numbers[i]>=length)//数组元素大小不合规范
                    return false;
            }
            for(int i=0;i<length;++i){
                while(numbers[i]!=i){
                    if(numbers[i]==numbers[numbers[i]]){
                        * duplication=numbers[i];
                        return true;
                    }
                    swap(numbers[i],numbers[numbers[i]]);
                }
            }
            return false;
        }
};
```
# 4.二维数组中的查找
[题目链接](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
### 题目描述
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
### 示例
    输入:
    matrix = [
      [1,   3,  5,  7],
      [10, 11, 16, 20],
      [23, 30, 34, 50]]
      target = 3
    输出: true
### 思路分析
该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。
如果当前元素大于target，则在左边查找；如果当前元素小于target，则在下面查找。(也可以从左下角查找，原理相同)
* 时间复杂度：O(m+n)，m为行数,n为列数;空间复杂度：O(1)
```cpp
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        if(!array.empty()){
        //选取左上角元素
        int row=0;
        int column=array[0].size()-1;
        while(row<array.size()&&column>=0){
            if(array[row][column]>target)//比target大，target只可能在左边
                --column;
            else if(array[row][column]<target)//比target小，target只可能在下边
                row++;
            else return true;
        }
       }
        return false;
    }
};
```
### 扩展题目
[LeetCode链接](https://leetcode-cn.com/problems/search-a-2d-matrix/)  
如果每行的第一个整数大于前一行的最后一个整数。可以将二维矩阵看作一维数组，对坐标进行转换，利用二分查找，实现O(long(mn))时间的查找。
坐标对应关系：一维转二维的行数：row=id/n；一维转二维的列数：col=id%n。
![image](https://github.com/piemon-nyah/Review/blob/master/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/%E5%9B%BE%E7%89%87/%E5%89%91%E6%8C%87offer4%E5%8F%98%E5%BD%A2%E9%A2%98%E7%9B%AE%E5%9B%BE%E7%A4%BA.png)
```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty()) return false;
        int row=matrix.size();
        int column=matrix[0].size();
        int left=0;
        int right=row*column-1;
        while(left<=right){
            int mid=(left+right)/2;
            if(matrix[mid/column][mid%column]==target) return true;
            else if(matrix[mid/column][mid%column]>target) right=mid-1;
            else left=mid+1;
        }
        return false;
    }
};
```
# 5.替换空格
[牛客链接](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
### 题目描述
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，。
### 示例
    当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy
### 思路分析
* 从前向后替换移动，后面的字符需要多次移动，时间复杂度为O(n^2)，效率较低。
* 先统计字符串中的空格字数，提前预留出空间，从后向前遍历，替换空格，每个字符只需移动一次，时间复杂度为O(n)。
```cpp
class Solution {
public:
    //length为总容量，不是原数组长度
	void replaceSpace(char *str,int length){
        if(str==nullptr||length<=0)
            return ;
        int oldLength=0;//原始长度
        int numberOfBlank=0;//字符串中空格的长度
        int i=0;
        while(str[i]!='\0'){
            ++oldLength;
            if(str[i]==' ')
                ++numberOfBlank;
            ++i;
        }
        int newLength=oldLength+2*numberOfBlank;//新字符串长度
        if(newLength>length)//容量不足
            return;
        //注意'\0'，不要-1
        int oldIndex=oldLength;//原字符位置
        int newIndex=newLength;//新字符位置
        //newIndex追上oldIndex时，则证明所有空格已替换完成
        while(oldIndex>=0&&newIndex>oldIndex){
            if(str[oldIndex]==' '){
                str[newIndex--]='0';
                str[newIndex--]='2';
                str[newIndex--]='%';
            }
            else
                str[newIndex--]=str[oldIndex];
            --oldIndex;
        }
    }
};
```
# 6.从尾到头打印链表
[牛客链接](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)  
### 题目描述
输入一个链表，按链表值从尾到头的顺序返回一个数组。
### 示例
    输入: 1->2->3->4->5->NULL
    输出: 5->4->3->2->1->NULL
### 思路分析
* 利用栈先进后出的特性实现
```cpp
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head){
        stack<ListNode*>s;
        vector<int>res;
        ListNode* pNode=head;
        while(pNode!=nullptr){
            s.push(pNode);
            pNode=pNode->next;
        }
        while(s.size()){//栈中还有元素
            int temp=s.top()->val;
            s.pop();
            res.push_back(temp);
        }
        return res;
    }
};
```
*  利用递归，每访问到一个节点的时候，先递归输出后面的节点，再输出该节点自身。
```cpp
class Solution {
public:
    vector<int>res;//注意res的位置
    vector<int> printListFromTailToHead(ListNode* head) {
        if(head!=NULL){
            if(head->next!=NULL){
                printListFromTailToHead(head->next);
            }
            res.push_back(head->val);
        }
        return res;
    }
};
```
# 7.重建二叉树
[牛客链接](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)
[LeetCode链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
### 题目描述
根据一棵树的前序遍历与中序遍历构造二叉树。假设树中没有重复的元素。
### 示例
	前序遍历 preorder = [3,9,20,15,7]
	中序遍历 inorder = [9,3,15,20,7]
	返回如下的二叉树：
    	 3
   		/ \
  	   9  20
     /  \
	15   7
### 思路分析
前序遍历的第一个值为根节点的值，在中序遍历中找到这个值的位置，将中序遍历结果分成两部分，前面就是左子树的中序遍历，后面为右子树的中序遍历，根据其长度，可以在前序遍历中找到左右子树的前序遍历。再从前序遍历中寻找下一个根节点，进行递归，直至所有节点被放进二叉树。
### 扩展题目
# 8.二叉树中的下一个节点
[题目连接]()
### 题目描述
### 示例
### 思路分析
# 9.用两个栈实现队列
[题目连接]()
### 题目描述
### 示例
### 思路分析
# 10.斐波那契数列
[题目连接]()
### 题目描述
### 示例
### 思路分析
