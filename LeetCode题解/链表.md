# 目录
## 1.环形链表I
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle/)
### 题目描述
给定一个链表，判断链表中是否有环。  
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果pos是-1，则在该链表中没有环。
### 示例
	输入：head = [3,2,0,-4], pos = 1
	输出：true
	解释：链表中有一个环，其尾部连接到第二个节点。
### 思路分析
* 利用快慢指针，快指针移动的速度是慢指针的两倍，如果有环，则快慢指针一定会相遇。
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr&&fast->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)
                return true;
        }
        return false;
    }
};
```
* 利用哈希表
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
    set<ListNode*>myset; 
    ListNode* p=head;
    while(p!=NULL)
    {
        if(myset.count(p)==0)
            myset.insert(p);
        else return true;
        p=p->next;
    }
    return false;
    }
};
```
[回到目录](#目录)
## 环形链表II
[LeetCode链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
### 题目描述
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
### 示例
	输入：head = [3,2,0,-4], pos = 1
	输出：1
	解释：链表中有一个环，其尾部连接到第二个节点
### 思路分析
![image](https://github.com/piemon-nyah/Review/blob/master/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/%E5%9B%BE%E7%89%87/%E5%89%91%E6%8C%87offer23%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9.png)
* 慢指针移动一步，快指针移动两步；
* 2distance(慢)=diatance(快)；
* 2(F+a)=F+a+n(a+b)->F=(n-1)a+nb=(n-1)(a+b)+b；
* 第一次相遇后，慢指针从头走，快指针从相遇点继续向前走，一定在入口处相遇。
```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=nullptr&&fast->next!=nullptr){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){//第一次相遇
                slow=head;
                while(slow!=fast){//第二次相遇
                    slow=slow->next;
                    fast=fast->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};
```
* 利用哈希表，找到第一个重复的节点
```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*>myset;
        ListNode* p=head;
        while(p){
            if(myset.count(p)==0)
                myset.insert(p);
            else return p;
            p=p->next;
        }
        return nullptr;
    }
};
```
