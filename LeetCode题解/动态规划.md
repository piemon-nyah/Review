# 目录
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
* ()[#]  
## 最长回文子串(medium)
[LeetCode5.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
### 题目描述
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
### 示例
	输入: "babad"
	输出: "bab"
	注意: "aba" 也是一个有效答案。
### 思路分析
　　对于字符串str，假设dp[i,j]=1表示str[i...j]是回文子串，那个必定存在dp[i+1,j-1]=1。这样最长回文子串就能分解成一系列子问题，可以利用动态规划求解了。  
首先构造状态转移方程:
```
         dp[i+1,j-1],str[i]==str[j]
dp[i,j]=
         0,str[i]!=str[j];
```
上面的状态转移方程表示，当str[i]=str[j]时，如果str[i+1...j-1]是回文串，则str[i...j]也是回文串；如果str[i+1...j-1]不是回文串，则str[i...j]不是回文串。  
初始状态:
* dp[i][i]=1
* dp[i][i+1]=1 if str[i]==str[i+1]
上式的意义是单个字符，两个相同字符都是回文串。
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n=s.size();
        if(n==0||n==1) return s;
        int start=0;//回文串起始位置
        int len=1;//回文串最大长度
        int dp[n][n];//定义二维动态数组
        memset(dp,0,sizeof(dp));//注意初始化为0，否则会产生随机值，影响结果，也可利用vector默认初始值为0
        for(int i=0;i<n;i++){
            dp[i][i]=1;
            if(i<n-1&&s[i]==s[i+1])
            {
                dp[i][i+1]=1;
                len=2;
                start=i;
            }
        }
        for(int l=3;l<=n;l++)//l表示检索的子串长度，等于3表示先检索长度为3的子串
        {
            for(int i=0;i+l-1<n;i++){
                int j=i+l-1;////以i为起始位置，j为长度为l的链的末位
                if(s[i]==s[j]&&dp[i+1][j-1]==1)//状态转移
                {
                    dp[i][j]=1;
                    start=i;
                    len=l;
                }
            }
        }
        return s.substr(start,len);//获取最长回文子串
    }
};
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
## 
[]()
### 题目描述

### 示例
### 思路分析
```cpp
```
(回到目录)[#目录]
